<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>浅浅学习分布式算法 | ᕕ( ᐛ )ᕗ xiaoli&#39;s blog</title>
<meta name="title" content="浅浅学习分布式算法" />
<meta name="description" content="分布式系统中如何保持各节点数据的一致性" />
<meta name="keywords" content="Paxos,Raft,分布式," />


<meta property="og:title" content="浅浅学习分布式算法" />
<meta property="og:description" content="分布式系统中如何保持各节点数据的一致性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zerlina-ysl.github.io/blog/distrubute_algorithms/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2023-03-06T16:18:03+08:00" />
<meta property="article:modified_time" content="2023-03-06T16:18:03+08:00" />




<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅浅学习分布式算法"/>
<meta name="twitter:description" content="分布式系统中如何保持各节点数据的一致性"/>



<meta itemprop="name" content="浅浅学习分布式算法">
<meta itemprop="description" content="分布式系统中如何保持各节点数据的一致性"><meta itemprop="datePublished" content="2023-03-06T16:18:03+08:00" />
<meta itemprop="dateModified" content="2023-03-06T16:18:03+08:00" />
<meta itemprop="wordCount" content="132">
<meta itemprop="keywords" content="Paxos,Raft,分布式," />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>ᕕ( ᐛ )ᕗ xiaoli&#39;s blog</h2>
</a>
<nav><a href="/">Home</a>

<a href="/diary/">diary</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>浅浅学习分布式算法</h1>
<p>
  <i>
    <time datetime='2023-03-06' pubdate>
      06 Mar, 2023
    </time>
  </i>
</p>

<content>
  <h2 id="paxos">Paxos</h2>
<p>Paxos是一个共识(consensus)算法，<em>共识算法解决的是分布式系统对某个提案（Proposal），大部分节点达成一致意见的过程。</em> <strong><strong>保证最终只有一个提案会被选定，提案被选定后进程也可以获取到被选定的提案</strong>。</strong></p>
<h3 id="前提">前提</h3>
<p><strong>假设不同参与者可以通过发送消息来通信，并使用普通的非拜占庭模式的异步模型</strong>，即每个参与者以任意速度执行，可能会出错而停止，也可能会重启,消息在传输中可能会花费任意的时间，可能会重复、丢失，但不会被损坏，即其内容不会被篡改，不会发生拜占庭式问题。</p>
<p><em><a href="https://zh.wikipedia.org/zh-hans/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭将军问题</a>：某国有许多军队，军队的将军需要制定一个统一的行动计划&mdash;进攻或撤退。将军们地理位置是分开的，只能靠通讯员通信，将军中存在叛徒，叛徒可以篡改消息，欺骗将军。~~理论研究显示，在3n+1的系统中，只有叛徒数目小于等于n，才有可能设计一个协议使得叛徒无论怎样作梗也能达成一致。~~即分布式计算中系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性</em></p>
<p>Paxos算法假设所有信息都是完整的，<strong>没有被篡改和伪造</strong>。</p>
<h3 id="主要术语">主要术语</h3>
<ul>
<li>
<p>Proposer：提案者</p>
</li>
<li>
<p>Proposal：提案，由Proposer提出，一个提案由一个编号及value形成的对组成，编号是为了防止混淆，保证提案的可区分性，value代表提案本身的内容。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。可以认为任何可以达成一致的信息都是一个提案。</p>
</li>
<li>
<p>Acceptor：提案的受理者，被动接受来自Proposer的提议，有权决定是否接受该提案。</p>
</li>
<li>
<p>Choose：被选定的提案，当有半数以上Acceptor接受该提案，就认为提案被选定。</p>
</li>
<li>
<p>Learner：被动接受来自Acceptor的消息，需要知道被选定的提案信息。</p>
</li>
</ul>
<p>假设有一组可以提出提案的进程集合，一个一致性算法需要保证以下三点：</p>
<ol>
<li>
<p>被提出的提案只有一个会被选定</p>
</li>
<li>
<p>如果没有提案被提出，就不会有被选定的提案。</p>
</li>
<li>
<p>当一个提案被选定后，进程可以获取被选定的提案信息。</p>
</li>
</ol>
<h3 id="安全性原则">安全性原则</h3>
<p>安全性是指那些需要保证永远都不会发生的事情，</p>
<ol>
<li>
<p>只有被提出的提案可以被选定</p>
</li>
<li>
<p>只能有一个value被选定</p>
</li>
<li>
<p>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定那个。</p>
</li>
</ol>
<h3 id="存活原则">存活原则</h3>
<p>存活是指那些最终一定会发生的事情</p>
<ol>
<li>
<p>最终会批准某个提案的value</p>
</li>
<li>
<p>一个value被批准了，其他服务器最终会学习到这个value</p>
</li>
</ol>
<h3 id="basic-paxos">Basic Paxos</h3>
<p>Paxos一致性算法分为两阶段提交：prepare阶段和Acceptor阶段</p>
<h3 id="preparepngacceptpngprepare阶段"><img src="prepare.png" alt=""><img src="accept.png" alt="">Prepare阶段</h3>
<p>阶段 a：proposer选择一个提案编号n，并将携带编号n的prepare请求发送给大多数的Acceptor。</p>
<p>阶段b：Acceptor收到Prepare消息后，如果提案编号大于它已经回复的所有prepare消息，Acceptor回复给Proposer一个promise消息，承诺不再接受小于n的提案。promise携带acceptor接受过的最大的编号。</p>
<h4 id="acceptor阶段">Acceptor阶段</h4>
<p>阶段a:  如果proposer从大多数acceptor中接收到对prepare请求的回复，它将向这些acceptors发送一个编号为n，value为v的accept请求，v是这些回复中最高编号的提案，或者响应报告中没有提案，v是任意值。</p>
<p>阶段b:  如果一个acceptor收到了编号为n的acceptor请求，它会<strong>接受该提案</strong>。除非已经回复过编号大于n的prepare请求。</p>
<h4 id="示例">示例</h4>
<p><img src="prepare_accept.jpeg" alt="img"></p>
<ol>
<li>
<p>P2分别向A2 A3发送序号为2的prepare请求，A2 A3之前没有接受过序号更大的prepare消息，因此会向P2返回一个序号为2的promise请求。</p>
</li>
<li>
<p>P1分别向A1 A2发送序号为1的prepare请求,A1之前没有接受过序号更大的prepare消息，因此会向P1返回一个序号为1的promise请求。而A2已经接受过序号为2的，因此会忽略P1的prepare请求。</p>
</li>
<li>
<p>P1为了将提案达成共识，会发送一个Acceptor请求，携带编号和value。</p>
</li>
<li>
<p>P2为了将提案达成共识，会发生Acceptor请求，携带编号和value。</p>
</li>
<li>
<p>A1会将共识发送给L1，并回复P1。</p>
</li>
<li>
<p>A2 A3 会将共识发送给L1，并回复P2。</p>
</li>
</ol>
<h4 id="活锁问题">活锁问题</h4>
<p><img src="https://github.com/vision9527/paxos/raw/main/images/live_lock.png" alt="live_lock"></p>
<p>P1提交的Proposal被拒绝时，可能存在因为Acceptor承诺返回了更大编号的Proposal，P1提高Proposal编号继续提交。一旦出现这种情况，两个Proposer都发现自己的编号过低转而提出更高编号的Proposal，这会导致死循环，该现象被称为活锁。你编号高，我再比你更高，反复如此，算法永远无法结束。</p>
<p>对于Basic Paxos来说，具有活锁问题，每次只能对单个提案形成决议，而决议的形成至少需要两次网络请求和应答，如果每个命令都需要通过Basic Paxos算法达到一致，会产生大量开销。
Basic Paxos的价值在于开拓了分布式共识算法的发展思路，但无法直接用于实践，只能作为学术研究。但是正如Mike Burrows所说，”There is only one consensus protocol, and that&rsquo;s “Paxos” — all other approaches a re just broken versions of Paxos“，许多实际应用的分布式算法如Raft、ZAB等都是基于Basic Paxos的改进。</p>
<p>multi Paxos的核心改进是增加了选主过程，而对于选主过程，其实是对“谁来当主节点”的共识。这里主要讲述Paxos的思想，对这些不再阐述。</p>
<h2 id="raft">Raft</h2>
<p>Raft算法对问题进行分解，分为“Leader Election”、“Safety”、“log compaction&quot;。思想上采用投票选举，遵从少数服从多数的原则。
<img src="https://pic2.zhimg.com/80/v2-e747e997d58aee9252b187c8434a1cc1_1440w.webp" alt="img"></p>
<h3 id="主要角色">主要角色</h3>
<p>Leader：领导者，主节点，负责协调和管理其他从节点。集群中只有一个leader，leader处理客户端的所有请求。</p>
<p>Candidate：候选者，集群中每个节点都可能成为候选者，候选者才有可能被选为领导者</p>
<p>Follower：跟随者，不可以发起选举。</p>
<p>term: 任期，raft把时间切分为任意长度的任期，任期是连续的整型数。每个服务器节点存储当前的任期，任期会随着时间递增。任期信息随着节点的通信而传递：如果当前服务器存储的任期小于其他服务器存储的任期，那就会更新该节点的任期信息为较大值。如果candidate或leader发现任期out of date,会立即转换为follower。</p>
<h3 id="leader-election">Leader election</h3>
<p>raft使用心跳机制触发选主。集群初始化时节点都是follower。leader会定期向follower发送心跳。如果follower超过一定时间仍未收到心跳，即<strong>election timeout</strong>,此时会认为没有可用的leader，开始选举新leader。</p>
<p>选举前，follower增加当前任期，并成为candidate。当收到集群中大多数节点的投票时，candidate在选举中胜出。一个节点最多只能投票给一个candidate，秉承着先来先投的原则。少数服从多数的原则保证最多一个candidate可以在投票中取胜。获胜的candidate作为leader，向其他follower发送心跳包。</p>
<p>candidate在选举时如果发现存在leader且leader的任期至少和candidate的一样大，candidate将承认该leader是合法的，并返回follower状态。</p>
<p>存在一种情况，投票中没有candidate胜出：如果过半follower同时变为candidate，选票会被平均，没有candidate收到大多数的投票。如果发生该情况，每个candidate会增大自己的任期并重启一轮选举。不过，raft也使用其他措施来减少该情况的发生：每个follower的election timeout是固定范围的随机数。</p>
<h3 id="log-replication">Log replication</h3>
<p>每个客户端请求 包含被复制状态机(replicated state machine)执行的命令。leader将命令作为一个新的Entry追加到log，之后通过rpc调用使其他服务器节点复制该entry。当entry被安全的复制后，leader会在存储机中应用该entry，并响应客户端。被存储在state machine的log entry包含leader收到entry的任期和表明在log中位置的索引。</p>
<p>leader决定什么时候应用entry到存储机(state machine)是安全的，此时entry被称为committed。一旦follower获知entry被应用，就会将entry应用在自己的state machine。raft确保commited是持久化的，并被<strong>所有</strong>state machine应用。</p>
<p><img src="log_replicated.jpeg" alt=""></p>
<ol>
<li>客户端发起请求,put(1,1)</li>
<li>leader收到请求，将信息复制到replicated state machine</li>
<li>leader并发请求其他follower同步该entry</li>
<li>follower将entry复制到replicated state machine，响应leader</li>
<li>当大多数follower都成功复制，leader在state machine应用该entry，并响应客户端。</li>
<li>当follower通过心跳信息得知entry被leader成功应用，也会在本机应用entry。</li>
</ol>
<h3 id="safety待办">Safety(待办)</h3>
<h2 id="reference">Reference</h2>
<p>维基百科中对于Paxos的解释：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FPaxos%25E7%25AE%2597%25E6%25B3%2595" title="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95">zh.wikipedia.org/wiki/Paxos%…</a></p>
<p>talkgo聊paxos的笔记：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvision9527%2Fpaxos" title="https://github.com/vision9527/paxos">github.com/vision9527/…</a></p>
<p>talkgo聊paxos：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1C5411L7qT" title="https://www.bilibili.com/video/BV1C5411L7qT">www.bilibili.com/video/BV1C5…</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf" title="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">lamport.azurewebsites.net/pubs/paxos-…</a></p>
<p>凤凰架构：<a href="https://link.juejin.cn?target=http%3A%2F%2Ficyfenix.cn%2Fdistribution%2Fconsensus%2Fraft.html" title="http://icyfenix.cn/distribution/consensus/raft.html">icyfenix.cn/distributio…</a></p>
<p>raft论文：<a href="https://link.zhihu.com/?target=https%3A//raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a></p>
<p>大佬解析raft：https://zhuanlan.zhihu.com/p/27207160</p>

</content>
<p>
  
  <a href="https://zerlina-ysl.github.io/tags/paxos/">#Paxos</a>
  
  <a href="https://zerlina-ysl.github.io/tags/raft/">#Raft</a>
  
  <a href="https://zerlina-ysl.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">#分布式</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
