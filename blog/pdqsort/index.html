<!doctype html><html lang=en-us><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/django.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/dockerfile.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/vim.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/gradle.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js></script><script>hljs.initHighlightingOnLoad()</script><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://zerlina-ysl.github.io/img/favicon.png><title>【go】pdqsort | ᕕ( ᐛ )ᕗ xiaoli's blog</title>
<meta name=title content="【go】pdqsort"><meta name=description content="1.排序算法 语言 排序算法 python timsort &mdash; &mdash; go1.18 混合排序，主要是快速排序 &mdash; &mdash; rust pdqsort &mdash; &mdash; c++ intro sort 1. 插入排序 将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。 2. 堆排序 利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复 3. 快速排序 递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。
当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。 实际场景下，根据序列长度划分后进行benchmark(16/128/1024)
完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大 完全有序情况下，插入排序最快 任何情况下，堆排序的表现比较稳定 2. pattern-defeating-quicksort 该算法结合三种排序算法的优点：
短序列，使用插入排序 其他情况用快排保证整体性能 当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度 短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。 何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。
1. 关键点 pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能 首个元素 实现简单，但完全有序情况效果不好 中位数 需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items 近似中位数，根据序列长度不同决定选择策略 短序列(<=8),选择固定元素 中序列(<=50),采样三个元素 长序列(>50),采样九个元素 pivot的采样方式可以让我们探知当前的序列状态 采样元素逆序&ndash;>序列可能逆序&ndash;>翻转序列 采样元素顺序&ndash;>序列可能顺序&ndash;>使用插入排序，有限制次数的插入排序 优化重复度较高的情况 如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素 2. 函数解析 1. choosePivot：选择pivot 支持三种选择方法：静态选择、三数取中、Tukey&rsquo;s ninther
当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴 如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴"><meta name=keywords content="go,排序算法,"><meta property="og:title" content="【go】pdqsort"><meta property="og:description" content="1.排序算法 语言 排序算法 python timsort &mdash; &mdash; go1.18 混合排序，主要是快速排序 &mdash; &mdash; rust pdqsort &mdash; &mdash; c++ intro sort 1. 插入排序 将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。 2. 堆排序 利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复 3. 快速排序 递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。
当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。 实际场景下，根据序列长度划分后进行benchmark(16/128/1024)
完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大 完全有序情况下，插入排序最快 任何情况下，堆排序的表现比较稳定 2. pattern-defeating-quicksort 该算法结合三种排序算法的优点：
短序列，使用插入排序 其他情况用快排保证整体性能 当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度 短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。 何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。
1. 关键点 pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能 首个元素 实现简单，但完全有序情况效果不好 中位数 需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items 近似中位数，根据序列长度不同决定选择策略 短序列(<=8),选择固定元素 中序列(<=50),采样三个元素 长序列(>50),采样九个元素 pivot的采样方式可以让我们探知当前的序列状态 采样元素逆序&ndash;>序列可能逆序&ndash;>翻转序列 采样元素顺序&ndash;>序列可能顺序&ndash;>使用插入排序，有限制次数的插入排序 优化重复度较高的情况 如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素 2. 函数解析 1. choosePivot：选择pivot 支持三种选择方法：静态选择、三数取中、Tukey&rsquo;s ninther
当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴 如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴"><meta property="og:type" content="article"><meta property="og:url" content="https://zerlina-ysl.github.io/blog/pdqsort/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-01-29T23:01:38+08:00"><meta property="article:modified_time" content="2025-01-29T23:01:38+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="【go】pdqsort"><meta name=twitter:description content="1.排序算法 语言 排序算法 python timsort &mdash; &mdash; go1.18 混合排序，主要是快速排序 &mdash; &mdash; rust pdqsort &mdash; &mdash; c++ intro sort 1. 插入排序 将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。 2. 堆排序 利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复 3. 快速排序 递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。
当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。 实际场景下，根据序列长度划分后进行benchmark(16/128/1024)
完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大 完全有序情况下，插入排序最快 任何情况下，堆排序的表现比较稳定 2. pattern-defeating-quicksort 该算法结合三种排序算法的优点：
短序列，使用插入排序 其他情况用快排保证整体性能 当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度 短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。 何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。
1. 关键点 pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能 首个元素 实现简单，但完全有序情况效果不好 中位数 需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items 近似中位数，根据序列长度不同决定选择策略 短序列(<=8),选择固定元素 中序列(<=50),采样三个元素 长序列(>50),采样九个元素 pivot的采样方式可以让我们探知当前的序列状态 采样元素逆序&ndash;>序列可能逆序&ndash;>翻转序列 采样元素顺序&ndash;>序列可能顺序&ndash;>使用插入排序，有限制次数的插入排序 优化重复度较高的情况 如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素 2. 函数解析 1. choosePivot：选择pivot 支持三种选择方法：静态选择、三数取中、Tukey&rsquo;s ninther
当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴 如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴"><meta itemprop=name content="【go】pdqsort"><meta itemprop=description content="1.排序算法 语言 排序算法 python timsort &mdash; &mdash; go1.18 混合排序，主要是快速排序 &mdash; &mdash; rust pdqsort &mdash; &mdash; c++ intro sort 1. 插入排序 将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。 2. 堆排序 利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复 3. 快速排序 递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。
当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。 实际场景下，根据序列长度划分后进行benchmark(16/128/1024)
完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大 完全有序情况下，插入排序最快 任何情况下，堆排序的表现比较稳定 2. pattern-defeating-quicksort 该算法结合三种排序算法的优点：
短序列，使用插入排序 其他情况用快排保证整体性能 当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度 短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。 何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。
1. 关键点 pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能 首个元素 实现简单，但完全有序情况效果不好 中位数 需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items 近似中位数，根据序列长度不同决定选择策略 短序列(<=8),选择固定元素 中序列(<=50),采样三个元素 长序列(>50),采样九个元素 pivot的采样方式可以让我们探知当前的序列状态 采样元素逆序&ndash;>序列可能逆序&ndash;>翻转序列 采样元素顺序&ndash;>序列可能顺序&ndash;>使用插入排序，有限制次数的插入排序 优化重复度较高的情况 如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素 2. 函数解析 1. choosePivot：选择pivot 支持三种选择方法：静态选择、三数取中、Tukey&rsquo;s ninther
当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴 如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴"><meta itemprop=datePublished content="2025-01-29T23:01:38+08:00"><meta itemprop=dateModified content="2025-01-29T23:01:38+08:00"><meta itemprop=wordCount content="168"><meta itemprop=keywords content="go,排序算法,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#030101;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><a href=/ class=title><h2>ᕕ( ᐛ )ᕗ xiaoli's blog</h2></a><nav><a href=/>Home</a>
<a href=/diary/>Diary</a>
<a href=/blog>Blog</a></nav></header><main><h1>【go】pdqsort</h1><p><i><time datetime=2025-01-29 pubdate>29 Jan, 2025
</time><span class=post-word-count>; 168 words</span></i></p><content><h2 id=1排序算法>1.排序算法</h2><table><thead><tr><th>语言</th><th>排序算法</th></tr></thead><tbody><tr><td>python</td><td>timsort</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>go1.18</td><td>混合排序，主要是快速排序</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>rust</td><td>pdqsort</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>c++</td><td>intro sort</td></tr></tbody></table><h3 id=1-插入排序>1. 插入排序</h3><p>将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。
<img src=insert.png alt></p><h3 id=2-堆排序>2. 堆排序</h3><p>利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复
<img src=heapSort.png alt></p><h3 id=3-快速排序>3. 快速排序</h3><p>递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。<br>当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。
<img src=quickSort.png alt></p><p>实际场景下，根据序列长度划分后进行benchmark(16/128/1024)</p><ul><li>完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大</li><li>完全有序情况下，插入排序最快</li><li>任何情况下，堆排序的表现比较稳定</li></ul><h2 id=2-pattern-defeating-quicksort>2. pattern-defeating-quicksort</h2><p>该算法结合三种排序算法的优点：</p><ul><li>短序列，使用插入排序</li><li>其他情况用快排保证整体性能</li><li>当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度</li></ul><p>短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。<br>何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。</p><h3 id=1-关键点>1. 关键点</h3><ul><li>pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能<ul><li>首个元素<ul><li>实现简单，但完全有序情况效果不好</li></ul></li><li>中位数<ul><li>需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items</li></ul></li><li>近似中位数，根据序列长度不同决定选择策略<ul><li>短序列(&lt;=8),选择固定元素</li><li>中序列(&lt;=50),采样三个元素</li><li>长序列(>50),采样九个元素</li></ul></li></ul></li><li>pivot的采样方式可以让我们探知当前的序列状态<ul><li>采样元素逆序&ndash;>序列<strong>可能</strong>逆序&ndash;>翻转序列</li><li>采样元素顺序&ndash;>序列<strong>可能</strong>顺序&ndash;>使用插入排序，有限制次数的插入排序</li></ul></li><li>优化重复度较高的情况<ul><li>如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素</li></ul></li></ul><p><img src=pdq.png alt></p><h3 id=2-函数解析>2. 函数解析</h3><h4 id=1-choosepivot选择pivot>1. choosePivot：选择pivot</h4><p>支持三种选择方法：静态选择、三数取中、Tukey&rsquo;s ninther<br>当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴
如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴</p><p><strong>swaps</strong>：寻找中位数的过程中的交换次数</p><ul><li>当swaps值为12(4*3)时，说明选择的pivot为降序，需要翻转序列(reverseRange)</li><li>当swaps值为9，数据可能顺序排列</li></ul><h4 id=2-partialinsertionsort局部插入排序>2. partialInsertionSort：局部插入排序</h4><p>当选择的pivot递增时，原始序列可能也递增，此时需要对序列进行局部插入排序。
该插入排序最多处理5对乱序元素，遍历序列发现乱序元素后，同时向两边移动乱序元素。
返回值含义：</p><ul><li>true：数组已经完全有序</li><li>false：<ol><li>数组太小（&lt;50）</li><li>处理了5次仍未完全有序</li><li>数组可能需要更多的排序操作</li></ol></li></ul><h4 id=3-partitionequal-处理大量重复元素的情况>3. partitionEqual: 处理大量重复元素的情况</h4><p><code>a > 0 && !data.Less(a-1, pivot)</code>的条件保证了此次数组中不存在小于枢轴值的元素，首次执行时a==0，不会执行该逻辑。<br>将枢轴移动到数组开头，找到第一个大于和等于枢轴的元素，交换位置。<br>如[3, 3, 3, 3, 5, 5, 3, 6, 3]，pivot = 3，运行后变为：[3 | 3, 3, 3, 3, 3, 3 | 5, 5, 6]，返回值 i 指向第一个大于3的位置</p><h4 id=4-partition根据pivot进行排序>4. partition：根据pivot进行排序</h4><p>将数组分成两部分：小于枢轴值的元素和大于等于枢轴值的元素，和一般的快排中partition本质一致。<br>在分区前会进行一个提前检查，若扫描发现原始数组已分区，则无需再次分区，alreadyPartitioned返回true。</p><h4 id=5-breakpatterns当分区不平衡时打乱数据>5. breakPatterns：当分区不平衡时，打乱数据</h4><p>通过随机交换中间位置的元素来打破数组中可能导致快速排序分区不平衡的模式
只处理中间位置附近的三个元素，使用xorshift 随机数生成器</p><ul><li>idx := a + (length/4)*2 - 1 为什么不直接写成a+length/2-1？<br>更清晰的语义表达，(length/4)*2 表示将数组分成四等份，取中间位置（第二个和第三个四分位之间），更直观地表达了"我们要处理的是数组中间部分"的意图</li></ul><h3 id=3-变量解析>3. 变量解析</h3><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>maxInsertion</td><td>当前序列长度小于maxInsertion时，使用插入排序</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>limit</td><td>当limit等于0时，使用堆排序保证排序性能，初始值为bits.Len(uint(n))</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>wasBalanced</td><td>通过比较左右子数组长度和阈值(len/8)来判断上一次partition是否平衡，如果不平衡，会触发breakPatterns来打乱数据</td></tr><tr><td>&mdash;</td><td>&mdash;</td></tr><tr><td>wasPartitioned</td><td>表示数组是否已经被分好区，即数组接近有序</td></tr></tbody></table><h2 id=4-总结>4. 总结</h2><p>本质上pdqsort是结合三种常用排序的优缺点的混合排序方式，基于benchmark编码，根据场景判断后选择合适的排序方式。</p><h2 id=5参考>5.参考</h2><p><a href=https://talkgo.org/t/topic/4342>https://talkgo.org/t/topic/4342</a><br><a href=https://mp.weixin.qq.com/s/5HqfRGqPyAhFt0krPgMHOQ>https://mp.weixin.qq.com/s/5HqfRGqPyAhFt0krPgMHOQ</a></p><p>This is a page about »PdqSort«.</p></content><p><a href=https://zerlina-ysl.github.io/tags/go/>#go</a>
<a href=https://zerlina-ysl.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/>#排序算法</a></p></main><footer><script src=https://utteranc.es/client.js repo=Zerlina-ysl/zerlina-ysl.github.io issue-term=title theme=github-light crossorigin=anonymous async></script>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>