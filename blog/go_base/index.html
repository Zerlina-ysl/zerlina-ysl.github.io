<!doctype html><html lang=en-us><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/django.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/dockerfile.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/vim.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/gradle.min.js></script><script src=https://cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js></script><script>hljs.initHighlightingOnLoad()</script><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://zerlina-ysl.github.io/img/favicon.png><title>go语言基础 | ᕕ( ᐛ )ᕗ xiaoli's blog</title>
<meta name=title content="go语言基础"><meta name=description content="1、gopath go1.15之前，使用绝对路径提供项目的工作目录
bin
存放编译生成的二进制文件。比如 执行命令 go install github.com/google/gops，bin目录会生成 gops 的二进制文件。 pkg
XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。 $GOPATH/pkg/mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置 $GOPATH/pkg/sumdb: go get命令缓存下载的checksum数据存放的位置 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，且如果执行go get使用第三方类库的时候会自动下载并安装到$GOPATH目录下。
使用问题 项目地址问题 需要将应用代码存放在固定的$GOPATH/src目录下;第三方套件go get后也需要放置在GOPATH/src的路径下才可以使用。
项目的Golang代码，和第三方的Golang文件混在一起, 项目文件管理麻烦
多个项目时设置多个gopath，不同的GoPath都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间
2、GOMODULE 使用gomodule管理第三方依赖,将第三方库储存在本地的空间，给项目代码引用
通过GO111MODULE控制：
on/不会去GOPATH目录下查找依赖 auto/根据当前目录来决定是否启用modules功能 off go.mod记录依赖包，go.sum保证依赖版本不被篡改
3、基本命令 go.mod Go 命令行工具会自动处理 go.mod 中指定的模块版本。当源代码中 import 指向的模块不存在于 go.mod 文件中时，Go 命令行工具会自动搜索这个模块，并将最新版本（最后一个 tag 且非预发布的稳定版本）添加到 go.mod 文件中。
go.sum https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/
详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。
# Go modules 打包整个模块包文件 zip 后再进行 hash 值 icode."><meta name=keywords content="go,"><meta property="og:title" content="go语言基础"><meta property="og:description" content="1、gopath go1.15之前，使用绝对路径提供项目的工作目录
bin
存放编译生成的二进制文件。比如 执行命令 go install github.com/google/gops，bin目录会生成 gops 的二进制文件。 pkg
XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。 $GOPATH/pkg/mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置 $GOPATH/pkg/sumdb: go get命令缓存下载的checksum数据存放的位置 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，且如果执行go get使用第三方类库的时候会自动下载并安装到$GOPATH目录下。
使用问题 项目地址问题 需要将应用代码存放在固定的$GOPATH/src目录下;第三方套件go get后也需要放置在GOPATH/src的路径下才可以使用。
项目的Golang代码，和第三方的Golang文件混在一起, 项目文件管理麻烦
多个项目时设置多个gopath，不同的GoPath都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间
2、GOMODULE 使用gomodule管理第三方依赖,将第三方库储存在本地的空间，给项目代码引用
通过GO111MODULE控制：
on/不会去GOPATH目录下查找依赖 auto/根据当前目录来决定是否启用modules功能 off go.mod记录依赖包，go.sum保证依赖版本不被篡改
3、基本命令 go.mod Go 命令行工具会自动处理 go.mod 中指定的模块版本。当源代码中 import 指向的模块不存在于 go.mod 文件中时，Go 命令行工具会自动搜索这个模块，并将最新版本（最后一个 tag 且非预发布的稳定版本）添加到 go.mod 文件中。
go.sum https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/
详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。
# Go modules 打包整个模块包文件 zip 后再进行 hash 值 icode."><meta property="og:type" content="article"><meta property="og:url" content="https://zerlina-ysl.github.io/blog/go_base/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-08-10T22:03:56+08:00"><meta property="article:modified_time" content="2024-08-10T22:03:56+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="go语言基础"><meta name=twitter:description content="1、gopath go1.15之前，使用绝对路径提供项目的工作目录
bin
存放编译生成的二进制文件。比如 执行命令 go install github.com/google/gops，bin目录会生成 gops 的二进制文件。 pkg
XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。 $GOPATH/pkg/mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置 $GOPATH/pkg/sumdb: go get命令缓存下载的checksum数据存放的位置 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，且如果执行go get使用第三方类库的时候会自动下载并安装到$GOPATH目录下。
使用问题 项目地址问题 需要将应用代码存放在固定的$GOPATH/src目录下;第三方套件go get后也需要放置在GOPATH/src的路径下才可以使用。
项目的Golang代码，和第三方的Golang文件混在一起, 项目文件管理麻烦
多个项目时设置多个gopath，不同的GoPath都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间
2、GOMODULE 使用gomodule管理第三方依赖,将第三方库储存在本地的空间，给项目代码引用
通过GO111MODULE控制：
on/不会去GOPATH目录下查找依赖 auto/根据当前目录来决定是否启用modules功能 off go.mod记录依赖包，go.sum保证依赖版本不被篡改
3、基本命令 go.mod Go 命令行工具会自动处理 go.mod 中指定的模块版本。当源代码中 import 指向的模块不存在于 go.mod 文件中时，Go 命令行工具会自动搜索这个模块，并将最新版本（最后一个 tag 且非预发布的稳定版本）添加到 go.mod 文件中。
go.sum https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/
详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。
# Go modules 打包整个模块包文件 zip 后再进行 hash 值 icode."><meta itemprop=name content="go语言基础"><meta itemprop=description content="1、gopath go1.15之前，使用绝对路径提供项目的工作目录
bin
存放编译生成的二进制文件。比如 执行命令 go install github.com/google/gops，bin目录会生成 gops 的二进制文件。 pkg
XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。 $GOPATH/pkg/mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置 $GOPATH/pkg/sumdb: go get命令缓存下载的checksum数据存放的位置 GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，且如果执行go get使用第三方类库的时候会自动下载并安装到$GOPATH目录下。
使用问题 项目地址问题 需要将应用代码存放在固定的$GOPATH/src目录下;第三方套件go get后也需要放置在GOPATH/src的路径下才可以使用。
项目的Golang代码，和第三方的Golang文件混在一起, 项目文件管理麻烦
多个项目时设置多个gopath，不同的GoPath都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间
2、GOMODULE 使用gomodule管理第三方依赖,将第三方库储存在本地的空间，给项目代码引用
通过GO111MODULE控制：
on/不会去GOPATH目录下查找依赖 auto/根据当前目录来决定是否启用modules功能 off go.mod记录依赖包，go.sum保证依赖版本不被篡改
3、基本命令 go.mod Go 命令行工具会自动处理 go.mod 中指定的模块版本。当源代码中 import 指向的模块不存在于 go.mod 文件中时，Go 命令行工具会自动搜索这个模块，并将最新版本（最后一个 tag 且非预发布的稳定版本）添加到 go.mod 文件中。
go.sum https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/
详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。
# Go modules 打包整个模块包文件 zip 后再进行 hash 值 icode."><meta itemprop=datePublished content="2024-08-10T22:03:56+08:00"><meta itemprop=dateModified content="2024-08-10T22:03:56+08:00"><meta itemprop=wordCount content="249"><meta itemprop=keywords content="go,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#030101;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><a href=/ class=title><h2>ᕕ( ᐛ )ᕗ xiaoli's blog</h2></a><nav><a href=/>Home</a>
<a href=/diary/>Diary</a>
<a href=/blog>Blog</a></nav></header><main><h1>go语言基础</h1><p><i><time datetime=2024-08-10 pubdate>10 Aug, 2024
</time><span class=post-word-count>; 249 words</span></i></p><content><h2 id=1gopath>1、gopath</h2><p>go1.15之前，使用绝对路径提供项目的工作目录</p><p><img src=https://i-blog.csdnimg.cn/blog_migrate/e24eb4475726bd9b6dd676e7630ac673.png alt=image-20220409140546638></p><ul><li><p>bin</p><ul><li>存放编译生成的二进制文件。比如 执行命令 go install github.com/google/gops，bin目录会生成 gops 的二进制文件。</li></ul></li><li><p>pkg</p><ul><li>XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。</li><li>$GOPATH/pkg/mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置</li><li>$GOPATH/pkg/sumdb: go get命令缓存下载的checksum数据存放的位置</li></ul></li></ul><p>GOPATH 模式下，我们需要将应用代码存放在固定的$GOPATH/src目录下，且如果执行go get使用第三方类库的时候会自动下载并安装到$GOPATH目录下。</p><h4 id=使用问题>使用问题</h4><ul><li>项目地址问题</li></ul><p>需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下;第三方套件go get后也需要放置在<code>GOPATH/src</code>的路径下才可以使用。</p><ol><li><p>项目的Golang代码，和第三方的Golang文件混在一起, 项目文件管理麻烦</p></li><li><p>多个项目时设置多个gopath，不同的<code>GoPath</code>都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间</p></li></ol><h2 id=2gomodule>2、GOMODULE</h2><p>使用gomodule管理第三方依赖,将第三方库储存在本地的空间，给项目代码引用</p><p>通过GO111MODULE控制：</p><ul><li>on/不会去<code>GOPATH</code>目录下查找依赖</li><li>auto/根据当前目录来决定是否启用<code>modules</code>功能</li><li>off</li></ul><p>go.mod记录依赖包，go.sum保证依赖版本不被篡改</p><h2 id=3基本命令>3、基本命令</h2><h3 id=gomod>go.mod</h3><p>Go 命令行工具会自动处理 go.mod 中指定的模块版本。当源代码中 <code>import</code> 指向的模块不存在于 go.mod 文件中时，Go 命令行工具会自动搜索这个模块，并将最新版本（最后一个 tag 且非预发布的稳定版本）添加到 go.mod 文件中。</p><h3 id=gosum>go.sum</h3><p><a href=https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/>https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/</a></p><p>详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p><pre tabindex=0><code>#  Go modules 打包整个模块包文件 zip 后再进行 hash 值
icode.baidu.com/baidu/health/limiter-sdk v0.7.0 h1:2H+dii8Nvhb0lRzXn4ZoqwxpjUcGYFjQUStbpvMYCDU=
# 针对 go.mod 的 hash 值
# 要不同时存在，要不只存在 go.mod hash。
# 当 Go 认为肯定用不到某个模块版本的时候就会省略它的 zip hash，只存在 go.mod hash 
icode.baidu.com/baidu/health/limiter-sdk v0.7.0/go.mod h1:2cX8JJzaN0/5K9PQt/3VILB/bmuOtGPxdtgXDiQ7fi0=
</code></pre><h3 id=gobin>GOBIN</h3><p><code>go install</code>编译存放路径。不允许设置多个路径。可以为空。为空时则遵循“约定优于配置”原则，可执行文件放在各自<code>GOPATH</code>目录的<code>bin</code>文件夹中（前提是：package main的main函数文件不能直接放到<code>GOPATH</code>的<code>src</code>下面。</p><h3 id=go-get--go-install>go get / go install</h3><p><a href=https://stackoverflow.com/questions/24878737/what-is-the-difference-between-go-get-and-go-install>https://stackoverflow.com/questions/24878737/what-is-the-difference-between-go-get-and-go-install</a></p><p><a href=https://tip.golang.org/doc/go1.16#modules>https://tip.golang.org/doc/go1.16#modules</a></p><ul><li><code>go get</code>：用于从远程代码存储库（如 GitHub）中下载或更新 Go 代码包。它会下载代码包并将其存储在 <code>$GOPATH/src</code> 目录下对应的位置，并编译代码包中的程序和库。如果目标包之前已经被下载过了，那么 <code>go get</code> 会尝试更新到最新版本，并重新编译程序和库文件。在更新完代码包后，<code>go get</code> 还会自动把下载的代码包的可执行文件复制到 <code>$GOPATH/bin</code> 目录下，以方便直接使用该可执行文件。</li><li><code>go install</code>：用于编译并安装 Go 代码包，并将其生成的可执行程序或库文件存储到 <code>$GOPATH/bin</code> 或者 <code>$GOPATH/pkg</code> 目录下。如果你在项目目录下执行 <code>go install</code>，它将会编译并安装当前项目的代码，生成可执行文件并将其保存到 <code>$GOPATH/bin</code> 目录下（如果项目是一个库，则生成的是 <code>.a</code> 文件，并将其存储到 <code>$GOPATH/pkg</code> 目录下）。</li></ul><table><thead><tr><th>命令</th><th>功能</th><th>下载位置</th><th>生成文件位置</th></tr></thead><tbody><tr><td>go get</td><td>从远程代码库中下载或更新 Go 代码包</td><td>$GOPATH/src</td><td>$GOPATH/bin</td></tr><tr><td>go install</td><td>编译并安装 Go 代码包</td><td>无需下载自身代码，$GOPATH/src 用于依赖包的查找</td><td>$GOPATH/bin或GOPATH/pkg</td></tr></tbody></table><p>go install，无论是否带有版本后缀，是当前模块模式下构建和安装软件包的推荐方式。</p><p>go-get应该与-d标志一起使用，以在不构建包的情况下调整当前模块的依赖关系，并且不推荐使用go-get来构建和安装包。在未来的版本中，-d标志将始终启用。</p><h2 id=4引用管理>4、引用管理</h2><p><a href=https://www.cnblogs.com/failymao/p/15087946.html>https://www.cnblogs.com/failymao/p/15087946.html</a></p><ul><li><strong>依赖包需要保持向后兼容，这包括可导出的函数、变量、类型、常量等不可以随便删除</strong>。</li></ul><p>如果该依赖包需要引入一个不兼容的特性，可以在该仓库中增加一个新的package.</p><p>在Go module时代，module版本号要遵循<strong>语义化版本规范</strong>，即版本号格式为<code>v&lt;major>.&lt;minor>.&lt;patch></code>，如<code>v1.2.3</code>。当有不兼容的改变时，需要增加major版本号，如v2.1.0。</p><ul><li><p>如果major版本号大于1，则major版本号需要显式地标记在module名字中，如<code>module github.com/my/mod/v2</code>。</p><p>这样做的好处是Go module 会把<code>module github.com/my/mod/v2</code> 和 <code>module github.com/my/mod</code>视做两个module，他们甚至可以被同时引用。</p></li><li><p>依赖包版本会随着引入其他依赖包而发生变化。</p></li></ul><p>Module A 依赖 Module M的v1.0.0版本，但之后 Module A 引入了 Module D，而Module D 依赖 Module M的v1.1.1版本，此时，由于依赖的传递，Module A也会选择v1.1.1版本。</p><p>此时会自动选择最小可用的版本，而不是最新的tag(v1.5.0)版本。</p><h3 id=最小版本选择minimal-version-selectionhttpsresearchswtchcomvgo-mvs>最小版本选择<a href=https://research.swtch.com/vgo-mvs>(Minimal version selection)</a></h3><p><img src="http://bj.bcebos.com/ibox-thumbnail98/711922dc6139f467298a63b8626eb3c7?authorization=bce-auth-v1%252Ffbe74140929444858491fbf2b6bc0935%252F2024-08-10T12%253A28%253A26Z%252F1800%252F%252Fdba7647b84283ed8e4da9b160f53ae03f6c7c76e36e851a52c9e70dbea25a203" alt=image-20240810202823355></p><h2 id=5toolchain>5、toolchain</h2><p><a href="https://blog.axiaoxin.com/post/go-toolchain/#gsc.tab=0">https://blog.axiaoxin.com/post/go-toolchain/#gsc.tab=0</a></p><p><a href=https://www.rectcircle.cn/posts/go-compatibility-2-forward/>https://www.rectcircle.cn/posts/go-compatibility-2-forward/</a></p><p>go1.21开始。Go Toolchain是Go语言的一套工具链，包括编译器、链接器、调试器、代码格式化工具等，用于支持Go语言的开发、编译、调试等流程</p><h4 id=向前兼容性>向前兼容性</h4><p>在以前的版本中，Go 工具链尝试编译依赖于新版本的代码时，可能会遇到兼容性问题。例如，如果代码依赖于 Go 1.18 引入的新特性，使用早期版本的 Go 编译器将会导致编译错误。但是，这些错误信息有时并不直观，可能仅仅显示为语法错误，而实际上是由于工具链版本不匹配。</p><p>在 Go 1.21 中，工具链会严格遵循 <code>go.mod</code> 文件中的版本声明。例如，如果你的 <code>go.mod</code> 文件中声明了 <code>go 1.21.1</code>，那么 Go 1.21.0 将无法编译这段代码。这种方式有效地避免了潜在的编译错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// go.mod 文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>module</span> <span style=color:#a6e22e>example</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#ae81ff>1.21</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 Go 1.18 的新特性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>genericFunction</span>[<span style=color:#a6e22e>T</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>value</span> <span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>T</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#f92672>/</span><span style=color:#a6e22e>example</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>1</span>: <span style=color:#a6e22e>module</span> <span style=color:#a6e22e>requires</span> <span style=color:#a6e22e>Go</span> <span style=color:#ae81ff>1.21</span>
</span></span></code></pre></div></content><p><a href=https://zerlina-ysl.github.io/tags/go/>#go</a></p></main><footer><script src=https://utteranc.es/client.js repo=Zerlina-ysl/zerlina-ysl.github.io issue-term=title theme=github-light crossorigin=anonymous async></script>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>