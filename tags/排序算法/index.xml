<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排序算法 on ᕕ( ᐛ )ᕗ xiaoli's blog</title><link>https://zerlina-ysl.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><description>Recent content in 排序算法 on ᕕ( ᐛ )ᕗ xiaoli's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 29 Jan 2025 23:01:38 +0800</lastBuildDate><atom:link href="https://zerlina-ysl.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>【go】pdqsort</title><link>https://zerlina-ysl.github.io/blog/pdqsort/</link><pubDate>Wed, 29 Jan 2025 23:01:38 +0800</pubDate><guid>https://zerlina-ysl.github.io/blog/pdqsort/</guid><description>1.排序算法 语言 排序算法 python timsort &amp;mdash; &amp;mdash; go1.18 混合排序，主要是快速排序 &amp;mdash; &amp;mdash; rust pdqsort &amp;mdash; &amp;mdash; c++ intro sort 1. 插入排序 将元素不断插入已排序的序列中。即不断交换，直到找到第一个比其小的元素。 2. 堆排序 利用堆的性质,构造一个大顶堆,将最大元素交换到最后一个位置，调整整个堆，如此反复 3. 快速排序 递归，不断分割序列直到序列整体有序。选定一个pivot,使用pivot分割序列，分成元素比pivot大和元素比pivot小的两个序列。
当pivot为中点，快排表现最好；当pivot选择为最大/最小元素时，快排表现最差。 实际场景下，根据序列长度划分后进行benchmark(16/128/1024)
完全随机情况下，短序列时插入排序最快，中、长序列时快排最快，但堆排序和快排的区别不大 完全有序情况下，插入排序最快 任何情况下，堆排序的表现比较稳定 2. pattern-defeating-quicksort 该算法结合三种排序算法的优点：
短序列，使用插入排序 其他情况用快排保证整体性能 当快排表现不佳时，使用堆排序保证最坏情况下的时间复杂度 短序列的长度为多少？12-32，在go语言的实现版本中，将短序列的长度选定为12。 何时从快排切换到堆排序？最终pivot距离序列两端距离小于length/8判定为快排表现不佳，这种情况次数达到bits.Len(length)时，切换为堆排序。bits.Len(length)表达的是一种阈值。
1. 关键点 pivot的选择：需要平衡寻找pivot的成本和pivot带来的性能 首个元素 实现简单，但完全有序情况效果不好 中位数 需遍历数组，性能不好,当array 的长度太长的话，寻找真正的 median 是一个非常昂贵的操作，需要存储所有的 items 近似中位数，根据序列长度不同决定选择策略 短序列(&amp;lt;=8),选择固定元素 中序列(&amp;lt;=50),采样三个元素 长序列(&amp;gt;50),采样九个元素 pivot的采样方式可以让我们探知当前的序列状态 采样元素逆序&amp;ndash;&amp;gt;序列可能逆序&amp;ndash;&amp;gt;翻转序列 采样元素顺序&amp;ndash;&amp;gt;序列可能顺序&amp;ndash;&amp;gt;使用插入排序，有限制次数的插入排序 优化重复度较高的情况 如果两次partition生成的pivot相同，即partition进行了无效分割，此时任务pivot的值为重复元素，limit-1，随机交换元素 2. 函数解析 1. choosePivot：选择pivot 支持三种选择方法：静态选择、三数取中、Tukey&amp;rsquo;s ninther
当数组长度大于等于 8 时，选择1/4、2/4、3/4处，在这三个位置中再找一个中位数作为最终的枢轴 如果长度大于等于 50 时，选择1/4、2/4、3/4处及其每处的相邻元素(共9个元素)的中位数作为最终的枢轴</description></item></channel></rss>